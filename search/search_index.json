{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"HTTP Core Do one thing, and do it well. The HTTP Core package provides a minimal low-level HTTP client, which does one thing only. Sending HTTP requests. It does not provide any high level model abstractions over the API, does not handle redirects, multipart uploads, building authentication headers, transparent HTTP caching, URL parsing, session cookie handling, content or charset decoding, handling JSON, environment based configuration defaults, or any of that Jazz. Some things HTTP Core does do: Sending HTTP requests. Provides both sync and async interfaces. Supports HTTP/1.1 and HTTP/2. Async backend support for asyncio , trio and curio . Automatic connection pooling. HTTP(S) proxy support. Installation For HTTP/1.1 only support, install with... $ pip install httpcore For HTTP/1.1 and HTTP/2 support, install with... $ pip install httpcore [ http2 ] Quickstart Here's an example of making an HTTP GET request using httpcore ... with httpcore . SyncConnectionPool () as http : status_code , headers , stream , ext = http . request ( method = b 'GET' , url = ( b 'https' , b 'example.org' , 443 , b '/' ), headers = [( b 'host' , b 'example.org' ), ( b 'user-agent' , 'httpcore' )] ) try : body = b '' . join ([ chunk for chunk in stream ]) finally : stream . close () print ( status_code , body ) Or, using async... async with httpcore . AsyncConnectionPool () as http : status_code , headers , stream , ext = await http . arequest ( method = b 'GET' , url = ( b 'https' , b 'example.org' , 443 , b '/' ), headers = [( b 'host' , b 'example.org' ), ( b 'user-agent' , 'httpcore' )] ) try : body = b '' . join ([ chunk async for chunk in stream ]) finally : await stream . aclose () print ( status_code , body ) Motivation You probably don't want to be using HTTP Core directly. It might make sense if you're writing something like a proxy service in Python, and you just want something at the lowest possible level, but more typically you'll want to use a higher level client library, such as httpx . The motivation for httpcore is: To provide a reusable low-level client library, that other packages can then build on top of. To provide a really clear interface split between the networking code and client logic, so that each is easier to understand and reason about in isolation.","title":"Introduction"},{"location":"#http-core","text":"Do one thing, and do it well. The HTTP Core package provides a minimal low-level HTTP client, which does one thing only. Sending HTTP requests. It does not provide any high level model abstractions over the API, does not handle redirects, multipart uploads, building authentication headers, transparent HTTP caching, URL parsing, session cookie handling, content or charset decoding, handling JSON, environment based configuration defaults, or any of that Jazz. Some things HTTP Core does do: Sending HTTP requests. Provides both sync and async interfaces. Supports HTTP/1.1 and HTTP/2. Async backend support for asyncio , trio and curio . Automatic connection pooling. HTTP(S) proxy support.","title":"HTTP Core"},{"location":"#installation","text":"For HTTP/1.1 only support, install with... $ pip install httpcore For HTTP/1.1 and HTTP/2 support, install with... $ pip install httpcore [ http2 ]","title":"Installation"},{"location":"#quickstart","text":"Here's an example of making an HTTP GET request using httpcore ... with httpcore . SyncConnectionPool () as http : status_code , headers , stream , ext = http . request ( method = b 'GET' , url = ( b 'https' , b 'example.org' , 443 , b '/' ), headers = [( b 'host' , b 'example.org' ), ( b 'user-agent' , 'httpcore' )] ) try : body = b '' . join ([ chunk for chunk in stream ]) finally : stream . close () print ( status_code , body ) Or, using async... async with httpcore . AsyncConnectionPool () as http : status_code , headers , stream , ext = await http . arequest ( method = b 'GET' , url = ( b 'https' , b 'example.org' , 443 , b '/' ), headers = [( b 'host' , b 'example.org' ), ( b 'user-agent' , 'httpcore' )] ) try : body = b '' . join ([ chunk async for chunk in stream ]) finally : await stream . aclose () print ( status_code , body )","title":"Quickstart"},{"location":"#motivation","text":"You probably don't want to be using HTTP Core directly. It might make sense if you're writing something like a proxy service in Python, and you just want something at the lowest possible level, but more typically you'll want to use a higher level client library, such as httpx . The motivation for httpcore is: To provide a reusable low-level client library, that other packages can then build on top of. To provide a really clear interface split between the networking code and client logic, so that each is easier to understand and reason about in isolation.","title":"Motivation"},{"location":"api/","text":"Developer Interface Async API Overview The AsyncHTTPTransport and AsyncByteStream classes provide the base interface which transport classes need to implement. class httpcore. AsyncHTTPTransport ( ) The base interface for sending HTTP requests. Concete implementations should subclass this class, and implement the request method, and optionally the close method. arequest ( self , method , url , headers=None , stream=None , ext=None ) The interface for sending a single HTTP request, and returning a response. Parameters: method - bytes - The HTTP method, such as b'GET' . url - Tuple[bytes, bytes, Optional[int], bytes] - The URL as a 4-tuple of (scheme, host, port, path). headers - Optional[List[Tuple[bytes, bytes]]] - Any HTTP headers to send with the request. stream - Optional[AsyncByteStream] - The body of the HTTP request. ext - Optional[dict] - A dictionary of optional extensions. Returns: A four-tuple of: status_code - int - The HTTP status code, such as 200 . headers - List[Tuple[bytes, bytes]] - Any HTTP headers included on the response. stream - AsyncByteStream - The body of the HTTP response. ext - dict - A dictionary of optional extensions. aclose ( self ) Close the implementation, which should close any outstanding response streams, and any keep alive connections. class httpcore. AsyncByteStream ( ) The base interface for request and response bodies. Concrete implementations should subclass this class, and implement the __aiter__ method, and optionally the aclose method. aiter ( self ) Yield bytes representing the request or response body. aclose ( self ) Must be called by the client to indicate that the stream has been closed. The AsyncConnectionPool class is a concrete implementation of AsyncHTTPTransport . class httpcore. AsyncConnectionPool ( ssl_context=None , max_connections=None , max_keepalive_connections=None , keepalive_expiry=None , http2=False , uds=None , local_address=None , retries=0 , max_keepalive=None , backend='auto' ) A connection pool for making HTTP requests. Parameters: ssl_context - Optional[SSLContext] - An SSL context to use for verifying connections. max_connections - Optional[int] - The maximum number of concurrent connections to allow. max_keepalive_connections - Optional[int] - The maximum number of connections to allow before closing keep-alive connections. keepalive_expiry - Optional[float] - The maximum time to allow before closing a keep-alive connection. http2 - bool - Enable HTTP/2 support. uds - str - Path to a Unix Domain Socket to use instead of TCP sockets. local_address - Optional[str] - Local address to connect from. Can also be used to connect using a particular address family. Using local_address=\"0.0.0.0\" will connect using an AF_INET address (IPv4), while using local_address=\"::\" will connect using an AF_INET6 address (IPv6). retries - int - The maximum number of retries when trying to establish a connection. backend - str - A name indicating which concurrency backend to use. The PlainByteStream and AsyncIteratorByteStream classes are concrete implementations of AsyncByteStream . class httpcore. PlainByteStream ( content ) A concrete implementation for either sync or async byte streams. Just handles a plain byte string as the content of the stream. stream = httpcore.PlainByteStream(b\"123\") class httpcore. AsyncIteratorByteStream ( aiterator , aclose_func=None ) A concrete implementation for async byte streams. Handles an async byte iterator as the content of the stream. async def generate_content (): ... stream = httpcore . AsyncIteratorByteStream ( generate_content ()) Sync API Overview The SyncHTTPTransport and SyncByteStream classes provide the base interface which transport classes need to implement. class httpcore. SyncHTTPTransport ( ) The base interface for sending HTTP requests. Concete implementations should subclass this class, and implement the request method, and optionally the close method. request ( self , method , url , headers=None , stream=None , ext=None ) The interface for sending a single HTTP request, and returning a response. Parameters: method - bytes - The HTTP method, such as b'GET' . url - Tuple[bytes, bytes, Optional[int], bytes] - The URL as a 4-tuple of (scheme, host, port, path). headers - Optional[List[Tuple[bytes, bytes]]] - Any HTTP headers to send with the request. stream - Optional[SyncByteStream] - The body of the HTTP request. ext - Optional[dict] - A dictionary of optional extensions. Returns: A four-tuple of: status_code - int - The HTTP status code, such as 200 . headers - List[Tuple[bytes, bytes]] - Any HTTP headers included on the response. stream - SyncByteStream - The body of the HTTP response. ext - dict - A dictionary of optional extensions. close ( self ) Close the implementation, which should close any outstanding response streams, and any keep alive connections. class httpcore. SyncByteStream ( ) The base interface for request and response bodies. Concrete implementations should subclass this class, and implement the __iter__ method, and optionally the close method. iter ( self ) Yield bytes representing the request or response body. close ( self ) Must be called by the client to indicate that the stream has been closed. The SyncConnectionPool class is a concrete implementation of SyncHTTPTransport . class httpcore. SyncConnectionPool ( ssl_context=None , max_connections=None , max_keepalive_connections=None , keepalive_expiry=None , http2=False , uds=None , local_address=None , retries=0 , max_keepalive=None , backend='sync' ) A connection pool for making HTTP requests. Parameters: ssl_context - Optional[SSLContext] - An SSL context to use for verifying connections. max_connections - Optional[int] - The maximum number of concurrent connections to allow. max_keepalive_connections - Optional[int] - The maximum number of connections to allow before closing keep-alive connections. keepalive_expiry - Optional[float] - The maximum time to allow before closing a keep-alive connection. http2 - bool - Enable HTTP/2 support. uds - str - Path to a Unix Domain Socket to use instead of TCP sockets. local_address - Optional[str] - Local address to connect from. Can also be used to connect using a particular address family. Using local_address=\"0.0.0.0\" will connect using an AF_INET address (IPv4), while using local_address=\"::\" will connect using an AF_INET6 address (IPv6). retries - int - The maximum number of retries when trying to establish a connection. backend - str - A name indicating which concurrency backend to use. The PlainByteStream and IteratorByteStream classes are concrete implementations of SyncByteStream . class httpcore. PlainByteStream ( content ) A concrete implementation for either sync or async byte streams. Just handles a plain byte string as the content of the stream. stream = httpcore.PlainByteStream(b\"123\") class httpcore. IteratorByteStream ( iterator , close_func=None ) A concrete implementation for sync byte streams. Handles a byte iterator as the content of the stream. def generate_content (): ... stream = httpcore . IteratorByteStream ( generate_content ())","title":"Developer Interface"},{"location":"api/#developer-interface","text":"","title":"Developer Interface"},{"location":"api/#async-api-overview","text":"The AsyncHTTPTransport and AsyncByteStream classes provide the base interface which transport classes need to implement. class httpcore. AsyncHTTPTransport ( ) The base interface for sending HTTP requests. Concete implementations should subclass this class, and implement the request method, and optionally the close method. arequest ( self , method , url , headers=None , stream=None , ext=None ) The interface for sending a single HTTP request, and returning a response. Parameters: method - bytes - The HTTP method, such as b'GET' . url - Tuple[bytes, bytes, Optional[int], bytes] - The URL as a 4-tuple of (scheme, host, port, path). headers - Optional[List[Tuple[bytes, bytes]]] - Any HTTP headers to send with the request. stream - Optional[AsyncByteStream] - The body of the HTTP request. ext - Optional[dict] - A dictionary of optional extensions. Returns: A four-tuple of: status_code - int - The HTTP status code, such as 200 . headers - List[Tuple[bytes, bytes]] - Any HTTP headers included on the response. stream - AsyncByteStream - The body of the HTTP response. ext - dict - A dictionary of optional extensions. aclose ( self ) Close the implementation, which should close any outstanding response streams, and any keep alive connections. class httpcore. AsyncByteStream ( ) The base interface for request and response bodies. Concrete implementations should subclass this class, and implement the __aiter__ method, and optionally the aclose method. aiter ( self ) Yield bytes representing the request or response body. aclose ( self ) Must be called by the client to indicate that the stream has been closed. The AsyncConnectionPool class is a concrete implementation of AsyncHTTPTransport . class httpcore. AsyncConnectionPool ( ssl_context=None , max_connections=None , max_keepalive_connections=None , keepalive_expiry=None , http2=False , uds=None , local_address=None , retries=0 , max_keepalive=None , backend='auto' ) A connection pool for making HTTP requests. Parameters: ssl_context - Optional[SSLContext] - An SSL context to use for verifying connections. max_connections - Optional[int] - The maximum number of concurrent connections to allow. max_keepalive_connections - Optional[int] - The maximum number of connections to allow before closing keep-alive connections. keepalive_expiry - Optional[float] - The maximum time to allow before closing a keep-alive connection. http2 - bool - Enable HTTP/2 support. uds - str - Path to a Unix Domain Socket to use instead of TCP sockets. local_address - Optional[str] - Local address to connect from. Can also be used to connect using a particular address family. Using local_address=\"0.0.0.0\" will connect using an AF_INET address (IPv4), while using local_address=\"::\" will connect using an AF_INET6 address (IPv6). retries - int - The maximum number of retries when trying to establish a connection. backend - str - A name indicating which concurrency backend to use. The PlainByteStream and AsyncIteratorByteStream classes are concrete implementations of AsyncByteStream . class httpcore. PlainByteStream ( content ) A concrete implementation for either sync or async byte streams. Just handles a plain byte string as the content of the stream. stream = httpcore.PlainByteStream(b\"123\") class httpcore. AsyncIteratorByteStream ( aiterator , aclose_func=None ) A concrete implementation for async byte streams. Handles an async byte iterator as the content of the stream. async def generate_content (): ... stream = httpcore . AsyncIteratorByteStream ( generate_content ())","title":"Async API Overview"},{"location":"api/#sync-api-overview","text":"The SyncHTTPTransport and SyncByteStream classes provide the base interface which transport classes need to implement. class httpcore. SyncHTTPTransport ( ) The base interface for sending HTTP requests. Concete implementations should subclass this class, and implement the request method, and optionally the close method. request ( self , method , url , headers=None , stream=None , ext=None ) The interface for sending a single HTTP request, and returning a response. Parameters: method - bytes - The HTTP method, such as b'GET' . url - Tuple[bytes, bytes, Optional[int], bytes] - The URL as a 4-tuple of (scheme, host, port, path). headers - Optional[List[Tuple[bytes, bytes]]] - Any HTTP headers to send with the request. stream - Optional[SyncByteStream] - The body of the HTTP request. ext - Optional[dict] - A dictionary of optional extensions. Returns: A four-tuple of: status_code - int - The HTTP status code, such as 200 . headers - List[Tuple[bytes, bytes]] - Any HTTP headers included on the response. stream - SyncByteStream - The body of the HTTP response. ext - dict - A dictionary of optional extensions. close ( self ) Close the implementation, which should close any outstanding response streams, and any keep alive connections. class httpcore. SyncByteStream ( ) The base interface for request and response bodies. Concrete implementations should subclass this class, and implement the __iter__ method, and optionally the close method. iter ( self ) Yield bytes representing the request or response body. close ( self ) Must be called by the client to indicate that the stream has been closed. The SyncConnectionPool class is a concrete implementation of SyncHTTPTransport . class httpcore. SyncConnectionPool ( ssl_context=None , max_connections=None , max_keepalive_connections=None , keepalive_expiry=None , http2=False , uds=None , local_address=None , retries=0 , max_keepalive=None , backend='sync' ) A connection pool for making HTTP requests. Parameters: ssl_context - Optional[SSLContext] - An SSL context to use for verifying connections. max_connections - Optional[int] - The maximum number of concurrent connections to allow. max_keepalive_connections - Optional[int] - The maximum number of connections to allow before closing keep-alive connections. keepalive_expiry - Optional[float] - The maximum time to allow before closing a keep-alive connection. http2 - bool - Enable HTTP/2 support. uds - str - Path to a Unix Domain Socket to use instead of TCP sockets. local_address - Optional[str] - Local address to connect from. Can also be used to connect using a particular address family. Using local_address=\"0.0.0.0\" will connect using an AF_INET address (IPv4), while using local_address=\"::\" will connect using an AF_INET6 address (IPv6). retries - int - The maximum number of retries when trying to establish a connection. backend - str - A name indicating which concurrency backend to use. The PlainByteStream and IteratorByteStream classes are concrete implementations of SyncByteStream . class httpcore. PlainByteStream ( content ) A concrete implementation for either sync or async byte streams. Just handles a plain byte string as the content of the stream. stream = httpcore.PlainByteStream(b\"123\") class httpcore. IteratorByteStream ( iterator , close_func=None ) A concrete implementation for sync byte streams. Handles a byte iterator as the content of the stream. def generate_content (): ... stream = httpcore . IteratorByteStream ( generate_content ())","title":"Sync API Overview"},{"location":"contributing/","text":"Contributing Thanks for considering contributing to HTTP Core! We welcome contributors to: Try HTTPX , as it is HTTP Core's main entry point, and report bugs/issues you find Help triage issues and investigate root causes of bugs Review Pull Requests of others Review, clarify and write documentation Participate in discussions Reporting Bugs or Other Issues HTTP Core is a fairly specialized library and its main purpose is to provide a solid base for HTTPX . HTTPX should be considered the main entry point to HTTP Core and as such we encourage users to test and raise issues in HTTPX's issue tracker where maintainers and contributors can triage and move to HTTP Core if appropriate. If you are convinced that the cause of the issue is on HTTP Core you're more than welcome to open an issue . Please attach as much detail as possible and, in case of a bug report, provide information like: OS platform or Docker image Python version Installed dependencies and versions ( python -m pip freeze ) Code snippet to reproduce the issue Error traceback and output It is quite helpful to increase the logging level of HTTP Core and include the output of your program. To do so set the HTTPCORE_LOG_LEVEL or HTTPX_LOG_LEVEL environment variables to TRACE , for example: $ HTTPCORE_LOG_LEVEL = TRACE python test_script.py TRACE [2020-06-06 09:55:10] httpcore._async.connection_pool - get_connection_from_pool=(b'https', b'localhost', 5000) TRACE [2020-06-06 09:55:10] httpcore._async.connection_pool - created connection=<httpcore._async.connection.AsyncHTTPConnection object at 0x1110fe9d0> ... The output will be quite long but it will help dramatically in diagnosing the problem. For more examples please refer to the environment variables documentation in HTTPX . Development To start developing HTTP Core create a fork of the repository on GitHub. Then clone your fork with the following command replacing YOUR-USERNAME with your GitHub username: $ git clone https://github.com/YOUR-USERNAME/httpcore You can now install the project and its dependencies using: $ cd httpcore $ scripts/install Unasync HTTP Core provides synchronous and asynchronous interfaces. As you can imagine, keeping two almost identical versions of code in sync can be quite time consuming. To work around this problem HTTP Core uses a technique called unasync , where the development is focused on the asynchronous version of the code and a script generates the synchronous version from it. As such developers should: Only make modifications in the asynchronous and shared portions of the code. In practice this roughly means avoiding the httpcore/_sync directory. Write tests only under async_tests , synchronous tests are also generated as part of the unasync process. Run scripts/unasync to generate the synchronous versions. Note the script is ran as part of other scripts as well, so you don't usually need to run this yourself. Run the entire test suite as decribed below. Testing and Linting We use custom shell scripts to automate testing, linting, and documentation building workflow. To run the tests, use: $ scripts/test Warning The test suite spawns testing servers on ports 8000 and 8001 . Make sure these are not in use, so the tests can run properly. You can run a single test script like this: $ scripts/test -- tests/async_tests/test_interfaces.py To run the code auto-formatting: $ scripts/lint Lastly, to run code checks separately (they are also run as part of scripts/test ), run: $ scripts/check Documenting Documentation pages are located under the docs/ folder. To run the documentation site locally (useful for previewing changes), use: $ scripts/docs Resolving Build / CI Failures Once you've submitted your pull request, the test suite will automatically run, and the results will show up in GitHub. If the test suite fails, you'll want to click through to the \"Details\" link, and try to identify why the test suite failed. Here are some common ways the test suite can fail: Check Job Failed This job failing means there is either a code formatting issue or type-annotation issue. You can look at the job output to figure out why it's failed or within a shell run: $ scripts/check It may be worth it to run $ scripts/lint to attempt auto-formatting the code and if that job succeeds commit the changes. Docs Job Failed This job failing means the documentation failed to build. This can happen for a variety of reasons like invalid markdown or missing configuration within mkdocs.yml . Python 3.X Job Failed This job failing means the unit tests failed or not all code paths are covered by unit tests. If tests are failing you will see this message under the coverage report: === 1 failed, 435 passed, 1 skipped, 1 xfailed in 11.09s === If tests succeed but coverage is lower than our current threshold, you will see this message under the coverage report: FAIL Required test coverage of 100% not reached. Total coverage: 99.00% Releasing This section is targeted at HTTPX maintainers. Before releasing a new version, create a pull request that includes: An update to the changelog : We follow the format from keepachangelog . Compare master with the tag of the latest release, and list all entries that are of interest to our users: Things that must go in the changelog: added, changed, deprecated or removed features, and bug fixes. Things that should not go in the changelog: changes to documentation, tests or tooling. Try sorting entries in descending order of impact / importance. Keep it concise and to-the-point. \ud83c\udfaf A version bump : see __version__.py . For an example, see #99 . Once the release PR is merged, create a new release including: Tag version like 0.9.3 . Release title Version 0.9.3 Description copied from the changelog. Once created this release will be automatically uploaded to PyPI. If something goes wrong with the PyPI job the release can be published using the scripts/publish script.","title":"Contributing"},{"location":"contributing/#contributing","text":"Thanks for considering contributing to HTTP Core! We welcome contributors to: Try HTTPX , as it is HTTP Core's main entry point, and report bugs/issues you find Help triage issues and investigate root causes of bugs Review Pull Requests of others Review, clarify and write documentation Participate in discussions","title":"Contributing"},{"location":"contributing/#reporting-bugs-or-other-issues","text":"HTTP Core is a fairly specialized library and its main purpose is to provide a solid base for HTTPX . HTTPX should be considered the main entry point to HTTP Core and as such we encourage users to test and raise issues in HTTPX's issue tracker where maintainers and contributors can triage and move to HTTP Core if appropriate. If you are convinced that the cause of the issue is on HTTP Core you're more than welcome to open an issue . Please attach as much detail as possible and, in case of a bug report, provide information like: OS platform or Docker image Python version Installed dependencies and versions ( python -m pip freeze ) Code snippet to reproduce the issue Error traceback and output It is quite helpful to increase the logging level of HTTP Core and include the output of your program. To do so set the HTTPCORE_LOG_LEVEL or HTTPX_LOG_LEVEL environment variables to TRACE , for example: $ HTTPCORE_LOG_LEVEL = TRACE python test_script.py TRACE [2020-06-06 09:55:10] httpcore._async.connection_pool - get_connection_from_pool=(b'https', b'localhost', 5000) TRACE [2020-06-06 09:55:10] httpcore._async.connection_pool - created connection=<httpcore._async.connection.AsyncHTTPConnection object at 0x1110fe9d0> ... The output will be quite long but it will help dramatically in diagnosing the problem. For more examples please refer to the environment variables documentation in HTTPX .","title":"Reporting Bugs or Other Issues"},{"location":"contributing/#development","text":"To start developing HTTP Core create a fork of the repository on GitHub. Then clone your fork with the following command replacing YOUR-USERNAME with your GitHub username: $ git clone https://github.com/YOUR-USERNAME/httpcore You can now install the project and its dependencies using: $ cd httpcore $ scripts/install","title":"Development"},{"location":"contributing/#unasync","text":"HTTP Core provides synchronous and asynchronous interfaces. As you can imagine, keeping two almost identical versions of code in sync can be quite time consuming. To work around this problem HTTP Core uses a technique called unasync , where the development is focused on the asynchronous version of the code and a script generates the synchronous version from it. As such developers should: Only make modifications in the asynchronous and shared portions of the code. In practice this roughly means avoiding the httpcore/_sync directory. Write tests only under async_tests , synchronous tests are also generated as part of the unasync process. Run scripts/unasync to generate the synchronous versions. Note the script is ran as part of other scripts as well, so you don't usually need to run this yourself. Run the entire test suite as decribed below.","title":"Unasync"},{"location":"contributing/#testing-and-linting","text":"We use custom shell scripts to automate testing, linting, and documentation building workflow. To run the tests, use: $ scripts/test Warning The test suite spawns testing servers on ports 8000 and 8001 . Make sure these are not in use, so the tests can run properly. You can run a single test script like this: $ scripts/test -- tests/async_tests/test_interfaces.py To run the code auto-formatting: $ scripts/lint Lastly, to run code checks separately (they are also run as part of scripts/test ), run: $ scripts/check","title":"Testing and Linting"},{"location":"contributing/#documenting","text":"Documentation pages are located under the docs/ folder. To run the documentation site locally (useful for previewing changes), use: $ scripts/docs","title":"Documenting"},{"location":"contributing/#resolving-build-ci-failures","text":"Once you've submitted your pull request, the test suite will automatically run, and the results will show up in GitHub. If the test suite fails, you'll want to click through to the \"Details\" link, and try to identify why the test suite failed. Here are some common ways the test suite can fail:","title":"Resolving Build / CI Failures"},{"location":"contributing/#check-job-failed","text":"This job failing means there is either a code formatting issue or type-annotation issue. You can look at the job output to figure out why it's failed or within a shell run: $ scripts/check It may be worth it to run $ scripts/lint to attempt auto-formatting the code and if that job succeeds commit the changes.","title":"Check Job Failed"},{"location":"contributing/#docs-job-failed","text":"This job failing means the documentation failed to build. This can happen for a variety of reasons like invalid markdown or missing configuration within mkdocs.yml .","title":"Docs Job Failed"},{"location":"contributing/#python-3x-job-failed","text":"This job failing means the unit tests failed or not all code paths are covered by unit tests. If tests are failing you will see this message under the coverage report: === 1 failed, 435 passed, 1 skipped, 1 xfailed in 11.09s === If tests succeed but coverage is lower than our current threshold, you will see this message under the coverage report: FAIL Required test coverage of 100% not reached. Total coverage: 99.00%","title":"Python 3.X Job Failed"},{"location":"contributing/#releasing","text":"This section is targeted at HTTPX maintainers. Before releasing a new version, create a pull request that includes: An update to the changelog : We follow the format from keepachangelog . Compare master with the tag of the latest release, and list all entries that are of interest to our users: Things that must go in the changelog: added, changed, deprecated or removed features, and bug fixes. Things that should not go in the changelog: changes to documentation, tests or tooling. Try sorting entries in descending order of impact / importance. Keep it concise and to-the-point. \ud83c\udfaf A version bump : see __version__.py . For an example, see #99 . Once the release PR is merged, create a new release including: Tag version like 0.9.3 . Release title Version 0.9.3 Description copied from the changelog. Once created this release will be automatically uploaded to PyPI. If something goes wrong with the PyPI job the release can be published using the scripts/publish script.","title":"Releasing"}]}